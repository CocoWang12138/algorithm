let EDITOR_CODE_TEMPLATES_GRAPH_THEORY_ADJ_LIST=[{prefix:"add",keyword:"add",caption:"add",meta:"邻接表加边",score:100,value:"add(int a, int b)  // 添加一条边a->b\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n"}],EDITOR_CODE_TEMPLATES_GRAPH_THEORY_DIJKSTRA=[],EDITOR_CODE_TEMPLATES_GRAPH_THEORY_SPFA=[{prefix:"spfa",keyword:"spfa",caption:"spfa",meta:"最短路SPFA",score:100,value:"spfa()  // 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1\n{\n    memset(dist, 0x3f, sizeof dist);\n    dist[1] = 0;\n\n    queue<int> q;\n    q.push(1);\n    st[1] = true;\n\n    while (q.size())\n    {\n        auto t = q.front();\n        q.pop();\n\n        st[t] = false;\n\n        for (int i = h[t]; i != -1; i = ne[i])\n        {\n            int j = e[i];\n            if (dist[j] > dist[t] + w[i])\n            {\n                dist[j] = dist[t] + w[i];\n                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入\n                {\n                    q.push(j);\n                    st[j] = true;\n                }\n            }\n        }\n    }\n\n    if (dist[n] == 0x3f3f3f3f) return -1;\n    return dist[n];\n}\n"}],EDITOR_CODE_TEMPLATES_GRAPH_THEORY=EDITOR_CODE_TEMPLATES_GRAPH_THEORY_ADJ_LIST.concat(EDITOR_CODE_TEMPLATES_GRAPH_THEORY_SPFA).concat(EDITOR_CODE_TEMPLATES_GRAPH_THEORY_DIJKSTRA),EDITOR_CODE_TEMPLATES=EDITOR_CODE_TEMPLATES_GRAPH_THEORY;
